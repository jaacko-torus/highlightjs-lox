{"version":3,"sources":["lox.ts","lox.js"],"names":["noneOf","list","regex","concat","join","hljs","console","log","IDENT_RE","LANGUAGE_KEYWORDS","LITERALS","BUILT_IN_VARIABLES","KEYWORDS","$pattern","keyword","literal","NUMBER","scope","variants","begin","relevance","PARAMS_CONTAINS","C_LINE_COMMENT_MODE","end","keywords","contains","PARAMS","excludeBegin","excludeEnd","CLASS_OR_EXTENDS","match","FUNCTION_DEFINITION","label","illegal","UPPER_CASE_CONSTANT","FUNCTION_CALL","lookahead","PROPERTY_ACCESS","lox","name","aliases","QUOTE_STRING_MODE","RE_STARTERS_RE","REGEXP_MODE","beginKeywords","UNDERSCORE_IDENT_RE","returnBegin","inherit","TITLE_MODE"],"mappings":"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","file":"lox.js","sourcesContent":["/**\n * @name Lox\n * @param {LanguageFn} hljs\n * @website http://craftinginterpreters.com/\n * @license MIT\n */\n\nimport type { HLJSRegex } from \"../types\";\nimport type { HLJSApi, Language, LanguageFn, Mode } from \"highlight.js\";\nimport hljs from \"highlight.js\";\n\nconsole.log(hljs)\n\nconst regex = (hljs as HLJSApi & HLJSRegex).regex\n\nconst IDENT_RE = \"[A-Za-z][0-9A-Za-z]*\"\n\nconst LANGUAGE_KEYWORDS = [\n\t\"class\",\n\t\"else\",\n\t\"for\",\n\t\"function\",\n\t\"if\",\n\t\"print\",\n\t\"return\",\n\t\"var\",\n\t\"while\",\n]\n\nconst LITERALS = [\n\t\"false\",\n\t\"nil\",\n\t\"true\",\n]\n\nconst BUILT_IN_VARIABLES = [\n\t\"super\",\n\t\"this\",\n]\n\nconst KEYWORDS = {\n\t$pattern: IDENT_RE,\n\tkeyword: LANGUAGE_KEYWORDS,\n\tliteral: LITERALS,\n\t\"variable.language\": BUILT_IN_VARIABLES\n};\n\nconst NUMBER: Mode = {\n\tscope: \"number\",\n\tvariants: [\n\t\t{ begin: \"[\\\\d]+\" },\n\t\t{ begin: \"\\\\d+(\\.\\\\d+)?\" },\n\t],\n\trelevance: 0\n};\n\nconst PARAMS_CONTAINS = [\n\thljs.C_LINE_COMMENT_MODE,\n\t// eat recursive parens in sub expressions\n\t{\n\t\tbegin: /\\(/,\n\t\tend: /\\)/,\n\t\tkeywords: KEYWORDS,\n\t\tcontains: [\"self\", hljs.C_LINE_COMMENT_MODE]\n\t} as Mode\n];\n\nconst PARAMS: Mode = {\n\tscope: \"params\",\n\tbegin: /\\(/,\n\tend: /\\)/,\n\texcludeBegin: true,\n\texcludeEnd: true,\n\tkeywords: KEYWORDS,\n\tcontains: PARAMS_CONTAINS\n};\n\nconst CLASS_OR_EXTENDS: Mode = {\n\tvariants: [\n\t\t// class Car < Vehicle\n\t\t{\n\t\t\tmatch: [\n\t\t\t\t/class/,\n\t\t\t\t/\\s+/,\n\t\t\t\tIDENT_RE,\n\t\t\t\t/\\s+/,\n\t\t\t\t/</,\n\t\t\t\t/\\s+/,\n\t\t\t],\n\t\t\tscope: {\n\t\t\t\t1: \"keyword\",\n\t\t\t\t3: \"title.class\",\n\t\t\t\t5: \"keyword\",\n\t\t\t\t7: \"title.class.inherited\"\n\t\t\t}\n\t\t},\n\t\t// class Car\n\t\t{\n\t\t\tmatch: [\n\t\t\t\t/class/,\n\t\t\t\t/\\s+/,\n\t\t\t\tIDENT_RE\n\t\t\t],\n\t\t\tscope: {\n\t\t\t\t1: \"keyword\",\n\t\t\t\t3: \"title.class\"\n\t\t\t}\n\t\t},\n\t]\n};\n\nconst FUNCTION_DEFINITION: Mode = {\n\tvariants: [\n\t\t{\n\t\t\tmatch: [\n\t\t\t\t/function/,\n\t\t\t\t/\\s+/,\n\t\t\t\tIDENT_RE,\n\t\t\t\t/(?=\\s*\\()/\n\t\t\t]\n\t\t},\n\t],\n\tscope: {\n\t\t1: \"keyword\",\n\t\t3: \"title.function\"\n\t},\n\tlabel: \"func.def\",\n\tcontains: [PARAMS],\n\tillegal: /%/\n};\n\nconst UPPER_CASE_CONSTANT: Mode = {\n\trelevance: 0,\n\tmatch: /\\b[A-Z][A-Z0-9]+\\b/,\n\tscope: \"variable.constant\"\n};\n\nfunction noneOf(list: string[]) {\n\treturn regex.concat(\"(?!\", list.join(\"|\"), \")\");\n}\n\nconst FUNCTION_CALL: Mode = {\n\tmatch: regex.concat(\n\t\t/\\b/,\n\t\tnoneOf([\"super\"]),\n\t\tIDENT_RE, regex.lookahead(/\\(/)),\n\tscope: \"title.function\",\n\trelevance: 0\n};\n\nconst PROPERTY_ACCESS: Mode = {\n\tbegin: regex.concat(/\\./, regex.lookahead(\n\t\tregex.concat(IDENT_RE, /(?![0-9A-Za-z(])/)\n\t)),\n\tend: IDENT_RE,\n\texcludeBegin: true,\n\tscope: \"property\",\n\trelevance: 0\n};\n\n// HLJSApi\n\n/**\n * @name Lox\n * @param {HLJSApi} hljs\n * @website http://craftinginterpreters.com/\n */\nconst lox: LanguageFn = (hljs: HLJSApi) => {\n\treturn {\n\t\tname: \"Lox\",\n\t\taliases: [\"lox\"],\n\t\tkeywords: KEYWORDS,\n\t\tillegal: /#(?![$_A-z])/,\n\t\tcontains: [\n\t\t\thljs.QUOTE_STRING_MODE,\n\t\t\thljs.C_LINE_COMMENT_MODE,\n\t\t\tNUMBER,\n\t\t\t{ // \"value\" container\n\t\t\t\tbegin: \"(\" + hljs.RE_STARTERS_RE + \"|\\\\b(return)\\\\b)\\\\s*\",\n\t\t\t\tkeywords: \"return\",\n\t\t\t\trelevance: 0,\n\t\t\t\tcontains: [\n\t\t\t\t\thljs.C_LINE_COMMENT_MODE,\n\t\t\t\t\thljs.REGEXP_MODE,\n\t\t\t\t\t{ // could be a comma delimited list of params to a function call\n\t\t\t\t\t\tbegin: /,/,\n\t\t\t\t\t\trelevance: 0\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tmatch: /\\s+/,\n\t\t\t\t\t\trelevance: 0\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t\tFUNCTION_DEFINITION,\n\t\t\t{\n\t\t\t\t// prevent this from getting swallowed up by function since they appear \"function like\"\n\t\t\t\tbeginKeywords: \"while if for\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t// we have to count the parens to make sure we actually have the correct\n\t\t\t\t// bounding ( ).  There could be any number of sub-expressions inside\n\t\t\t\t// also surrounded by parens.\n\t\t\t\tbegin: \"\\\\b(?!function)\" + hljs.UNDERSCORE_IDENT_RE +\n\t\t\t\t\t\"\\\\(\" + // first parens\n\t\t\t\t\t\"[^()]*(\\\\(\" +\n\t\t\t\t\t\"[^()]*(\\\\(\" +\n\t\t\t\t\t\"[^()]*\" +\n\t\t\t\t\t\"\\\\)[^()]*)*\" +\n\t\t\t\t\t\"\\\\)[^()]*)*\" +\n\t\t\t\t\t\"\\\\)\\\\s*\\\\{\", // end parens\n\t\t\t\treturnBegin: true,\n\t\t\t\tlabel: \"func.def\",\n\t\t\t\tcontains: [\n\t\t\t\t\tPARAMS,\n\t\t\t\t\thljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE, scope: \"title.function\" })\n\t\t\t\t]\n\t\t\t},\n\t\t\tPROPERTY_ACCESS,\n\t\t\t{\n\t\t\t\tmatch: [/\\binit(?=\\s*\\()/],\n\t\t\t\tscope: { 1: \"title.function\" },\n\t\t\t\tcontains: [PARAMS]\n\t\t\t},\n\t\t\tFUNCTION_CALL,\n\t\t\tUPPER_CASE_CONSTANT,\n\t\t\tCLASS_OR_EXTENDS,\n\t\t\t{\n\t\t\t\tmatch: /\\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`\n\t\t\t}\n\t\t]\n\t} as Language;\n}\n\nexport default lox;","/**\n * @name Lox\n * @param {LanguageFn} hljs\n * @website http://craftinginterpreters.com/\n * @license MIT\n */\nimport hljs from \"highlight.js\";\nconsole.log(hljs);\nconst regex = hljs.regex;\nconst IDENT_RE = \"[A-Za-z][0-9A-Za-z]*\";\nconst LANGUAGE_KEYWORDS = [\n    \"class\",\n    \"else\",\n    \"for\",\n    \"function\",\n    \"if\",\n    \"print\",\n    \"return\",\n    \"var\",\n    \"while\",\n];\nconst LITERALS = [\n    \"false\",\n    \"nil\",\n    \"true\",\n];\nconst BUILT_IN_VARIABLES = [\n    \"super\",\n    \"this\",\n];\nconst KEYWORDS = {\n    $pattern: IDENT_RE,\n    keyword: LANGUAGE_KEYWORDS,\n    literal: LITERALS,\n    \"variable.language\": BUILT_IN_VARIABLES\n};\nconst NUMBER = {\n    scope: \"number\",\n    variants: [\n        { begin: \"[\\\\d]+\" },\n        { begin: \"\\\\d+(\\.\\\\d+)?\" },\n    ],\n    relevance: 0\n};\nconst PARAMS_CONTAINS = [\n    hljs.C_LINE_COMMENT_MODE,\n    // eat recursive parens in sub expressions\n    {\n        begin: /\\(/,\n        end: /\\)/,\n        keywords: KEYWORDS,\n        contains: [\"self\", hljs.C_LINE_COMMENT_MODE]\n    }\n];\nconst PARAMS = {\n    scope: \"params\",\n    begin: /\\(/,\n    end: /\\)/,\n    excludeBegin: true,\n    excludeEnd: true,\n    keywords: KEYWORDS,\n    contains: PARAMS_CONTAINS\n};\nconst CLASS_OR_EXTENDS = {\n    variants: [\n        // class Car < Vehicle\n        {\n            match: [\n                /class/,\n                /\\s+/,\n                IDENT_RE,\n                /\\s+/,\n                /</,\n                /\\s+/,\n            ],\n            scope: {\n                1: \"keyword\",\n                3: \"title.class\",\n                5: \"keyword\",\n                7: \"title.class.inherited\"\n            }\n        },\n        // class Car\n        {\n            match: [\n                /class/,\n                /\\s+/,\n                IDENT_RE\n            ],\n            scope: {\n                1: \"keyword\",\n                3: \"title.class\"\n            }\n        },\n    ]\n};\nconst FUNCTION_DEFINITION = {\n    variants: [\n        {\n            match: [\n                /function/,\n                /\\s+/,\n                IDENT_RE,\n                /(?=\\s*\\()/\n            ]\n        },\n    ],\n    scope: {\n        1: \"keyword\",\n        3: \"title.function\"\n    },\n    label: \"func.def\",\n    contains: [PARAMS],\n    illegal: /%/\n};\nconst UPPER_CASE_CONSTANT = {\n    relevance: 0,\n    match: /\\b[A-Z][A-Z0-9]+\\b/,\n    scope: \"variable.constant\"\n};\nfunction noneOf(list) {\n    return regex.concat(\"(?!\", list.join(\"|\"), \")\");\n}\nconst FUNCTION_CALL = {\n    match: regex.concat(/\\b/, noneOf([\"super\"]), IDENT_RE, regex.lookahead(/\\(/)),\n    scope: \"title.function\",\n    relevance: 0\n};\nconst PROPERTY_ACCESS = {\n    begin: regex.concat(/\\./, regex.lookahead(regex.concat(IDENT_RE, /(?![0-9A-Za-z(])/))),\n    end: IDENT_RE,\n    excludeBegin: true,\n    scope: \"property\",\n    relevance: 0\n};\n// HLJSApi\n/**\n * @name Lox\n * @param {HLJSApi} hljs\n * @website http://craftinginterpreters.com/\n */\nconst lox = (hljs) => {\n    return {\n        name: \"Lox\",\n        aliases: [\"lox\"],\n        keywords: KEYWORDS,\n        illegal: /#(?![$_A-z])/,\n        contains: [\n            hljs.QUOTE_STRING_MODE,\n            hljs.C_LINE_COMMENT_MODE,\n            NUMBER,\n            {\n                begin: \"(\" + hljs.RE_STARTERS_RE + \"|\\\\b(return)\\\\b)\\\\s*\",\n                keywords: \"return\",\n                relevance: 0,\n                contains: [\n                    hljs.C_LINE_COMMENT_MODE,\n                    hljs.REGEXP_MODE,\n                    {\n                        begin: /,/,\n                        relevance: 0\n                    },\n                    {\n                        match: /\\s+/,\n                        relevance: 0\n                    },\n                ],\n            },\n            FUNCTION_DEFINITION,\n            {\n                // prevent this from getting swallowed up by function since they appear \"function like\"\n                beginKeywords: \"while if for\"\n            },\n            {\n                // we have to count the parens to make sure we actually have the correct\n                // bounding ( ).  There could be any number of sub-expressions inside\n                // also surrounded by parens.\n                begin: \"\\\\b(?!function)\" + hljs.UNDERSCORE_IDENT_RE +\n                    \"\\\\(\" + // first parens\n                    \"[^()]*(\\\\(\" +\n                    \"[^()]*(\\\\(\" +\n                    \"[^()]*\" +\n                    \"\\\\)[^()]*)*\" +\n                    \"\\\\)[^()]*)*\" +\n                    \"\\\\)\\\\s*\\\\{\",\n                returnBegin: true,\n                label: \"func.def\",\n                contains: [\n                    PARAMS,\n                    hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE, scope: \"title.function\" })\n                ]\n            },\n            PROPERTY_ACCESS,\n            {\n                match: [/\\binit(?=\\s*\\()/],\n                scope: { 1: \"title.function\" },\n                contains: [PARAMS]\n            },\n            FUNCTION_CALL,\n            UPPER_CASE_CONSTANT,\n            CLASS_OR_EXTENDS,\n            {\n                match: /\\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`\n            }\n        ]\n    };\n};\nexport default lox;"]}